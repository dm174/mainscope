# Домашнее задание к занятию «11. Coroutines в Android»

Выполненное задание прикрепите ссылкой на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

**Важно**: ознакомьтесь со ссылками на главной странице [репозитория с домашними заданиями](../README.md).

**Важно**: если у вас что-то не получилось, оформите Issue. [Шаблон для оформления](../report-requirements.md).

## Как сдавать задачи

1. Откройте ваш проект Android-приложения с предыдущего ДЗ (можно взять код из лекции).
1. Сделайте необходимые коммиты.
1. Сделайте пуш. Удостоверьтесь, что ваш код появился на GitHub.
1. Ссылку на ваш проект прикрепите в личном кабинете на сайте [netology.ru](https://netology.ru).
1. Необязательные задачи можно не сдавать. На зачёт это не повлияет. 

## Задача №1. Remove & likes

### Легенда

[Используя код и сервер из лекции,](https://github.com/netology-code/andin-code/tree/master/10_mainscope) реализуйте в проекте функциональность удаления и проставления лайков. Для этого нужно отредактировать `PostViewModel` и `PostRepositoryImpl`:

```kotlin
// PostViewModel
fun likeById(id: Long) {
    TODO()
}

fun removeById(id: Long) {
    TODO()
}

// PostRepositoryImpl
override suspend fun removeById(id: Long) {
    TODO("Not yet implemented")
}

override suspend fun likeById(id: Long) {
    TODO("Not yet implemented")
}
```

Логика работы:
1. Сначала модифицируете запись в локальной БД или удаляете.
1. Затем отправляете соответствующий запрос в API (HTTP).

Не забудьте об обработке ошибок и кнопке `Retry` в случае, если запрос в API завершился с ошибкой (в том числе в случае отсутствия сетевого соединения*).

Примечание*: не обязательно перезапускать сервер. Достаточно отключить сеть в шторке телефона/эмулятора.

### Результат

Опубликуйте изменения в виде Pull Request в вашем проекте на GitHub.

Результат пришлите ссылкой на PR GitHub-проект в личном кабинете студента на сайте [netology.ru](https://netology.ru).

## Задача №2. Save*

**Важно**: это необязательная задача. Её можно не выполнять. На зачёте это не скажется.

В текущей реализации сохранения мы сначала отправляем запрос в API и только в случае получения успешного ответа добавляем его в локальную БД. Пост появляется в `RecyclerView`:
```kotlin
override suspend fun save(post: Post) {
    try {
        val response = PostsApi.service.save(post)
        if (!response.isSuccessful) {
            throw ApiError(response.code(), response.message())
        }

        val body = response.body() ?: throw ApiError(response.code(), response.message())
        dao.insert(PostEntity.fromDto(body))
    } catch (e: IOException) {
        throw NetworkError
    } catch (e: Exception) {
        throw UnknownError
    }
}
```

Попробуйте сделать наоборот: сначала сохранить в локальную БД, чтобы он сразу появился в `RecyclerView`, а затем уже сделать запрос в API.

<details>
<summary>Подсказка</summary>

Для этого вам стоит подумать над двумя вопросами:
1. Какой `id` должен быть у поста, ведь `id` присваивается на сервере?
1. Как отделять несохранённые на сервере посты от сохранённых? Например, в мессенджерах Telegram/WhatsApp рисуется специальная иконка, если сообщение ещё не сохранено на сервере.

Для реализации второго пункта внесите в `PostEntity` дополнительные поля, отвечающие за этот статус. На базе них можно рисовать иконку статуса в карточке поста + продумывать механику взаимодействия: например, несохранённый пост нельзя лайкнуть.
</details>

Не забудьте о `Retry` для повторной попытки вызова API сохранения, если возникнут проблемы. Например, из-за отсутствия сетевого подключения.

### Результат

Опубликуйте изменения в виде Pull Request в вашем проекте на GitHub.

Результат пришлите ссылкой на PR GitHub-проект в личном кабинете студента на сайте [netology.ru](https://netology.ru).
